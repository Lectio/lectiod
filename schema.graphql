# scalar SmallText
# scalar MediumText
# scalar LargeText
# scalar ExtraLargeText
scalar URLText
scalar RegularExpression
scalar ErrorMessage
scalar ConfigurationName

scalar IdentityPrincipal
scalar IdentityPassword
scalar IdentityKey

# scalar Document
# scalar File

# scalar Date
# scalar PastDate
# scalar FutureDate
# scalar DateTime
# scalar PastDateTime
# scalar FutureDateTime
# scalar Timestamp

scalar AuthenticatedSessionTimeout

enum AuthenticationType {
  SINGLE_FACTOR
}

enum AuthenticatedSessionType {
  EPHEMERAL
}

interface AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
}

interface AuthenticatedSession {
  id: ID!
  type: AuthenticatedSessionType!
  identity: AuthenticationIdentity!
  timeOut: AuthenticatedSessionTimeout!
}

interface Party {
  id: ID!
  name: String!  
}

type Person implements Party {
  id: ID!
  name: String!
  firstName: String!
  lastName: String!
  users : [UserIdentity]
  services : [ServiceIdentity]
}

type UserIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  password : IdentityPassword!
  person: Person!
}

type ServiceIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  key : IdentityKey!
}

type OrganizationalUnit implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Organization implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Tenant implements Party {
  id: ID!
  name: String!
  org: Organization!
}

# StorageType enumerates the different kinds of storage Lectio supports
enum StorageType {
  FILE_SYSTEM
}

type FileStorageConfiguration {
  basePath : String!
}

type StorageConfiguration {
  type: StorageType!
  filesys : FileStorageConfiguration
}

type HarvestDirectivesConfiguration {
  ignoreURLsRegExprs : [RegularExpression]
  removeParamsFromURLsRegEx : [RegularExpression]
  followHTMLRedirects : Boolean!
}

type Configuration {
  name : ConfigurationName!
  storage: StorageConfiguration!
  harvest : HarvestDirectivesConfiguration!
  errors: [ErrorMessage]
}

type HarvestedResourceUrls {
  original : URLText!
  final : URLText!
  cleaned : URLText!
  resolved : URLText!
}

type HarvestedResource {
  urls : HarvestedResourceUrls!
  isHTMLRedirect : Boolean!
  isCleaned : Boolean!
  redirectURL : URLText
}

type IgnoredResource {
  urls : HarvestedResourceUrls!
  reason: String!
}

type UnharvestedResource {
  url : URLText!
  reason: String!
}

type HarvestedResources {
  text: String!
  harvested: [HarvestedResource]
  ignored : [IgnoredResource]
  invalid : [UnharvestedResource]
}

type Query {
  configs : [Configuration]
  config(name : ConfigurationName = "DEFAULT"): Configuration
  urlsInText(config : ConfigurationName = "DEFAULT", text: String!): HarvestedResources
}

type Mutation {
  discoverURLsinText(config : ConfigurationName = "DEFAULT", text : String!) : HarvestedResources
}
