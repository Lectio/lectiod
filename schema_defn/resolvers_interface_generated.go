// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package schema_defn

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"

	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	Mutation_establishSimulatedSession(ctx context.Context, authorization PrivilegedAuthorizationInput, settings SettingsBundleName) (AuthenticatedSession, error)
	Mutation_refreshSession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (AuthenticatedSession, error)
	Mutation_destroySession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (bool, error)
	Mutation_destroyAllSessions(ctx context.Context, authorization PrivilegedAuthorizationInput) (AuthenticatedSessionsCount, error)
	Mutation_saveURLsinText(ctx context.Context, authorization AuthorizationInput, destination StorageDestinationInput, text string) (*HarvestedResources, error)

	Query_asymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error)
	Query_asymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error)
	Query_settingsBundles(ctx context.Context, authorization PrivilegedAuthorizationInput) ([]*SettingsBundle, error)
	Query_settingsBundle(ctx context.Context, authorization PrivilegedAuthorizationInput, name SettingsBundleName) (*SettingsBundle, error)
	Query_urlsInText(ctx context.Context, authorization AuthorizationInput, text string) (*HarvestedResources, error)
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}
type MutationResolver interface {
	EstablishSimulatedSession(ctx context.Context, authorization PrivilegedAuthorizationInput, settings SettingsBundleName) (AuthenticatedSession, error)
	RefreshSession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (AuthenticatedSession, error)
	DestroySession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (bool, error)
	DestroyAllSessions(ctx context.Context, authorization PrivilegedAuthorizationInput) (AuthenticatedSessionsCount, error)
	SaveURLsinText(ctx context.Context, authorization AuthorizationInput, destination StorageDestinationInput, text string) (*HarvestedResources, error)
}
type QueryResolver interface {
	AsymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error)
	AsymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error)
	SettingsBundles(ctx context.Context, authorization PrivilegedAuthorizationInput) ([]*SettingsBundle, error)
	SettingsBundle(ctx context.Context, authorization PrivilegedAuthorizationInput, name SettingsBundleName) (*SettingsBundle, error)
	UrlsInText(ctx context.Context, authorization AuthorizationInput, text string) (*HarvestedResources, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) Mutation_establishSimulatedSession(ctx context.Context, authorization PrivilegedAuthorizationInput, settings SettingsBundleName) (AuthenticatedSession, error) {
	return s.r.Mutation().EstablishSimulatedSession(ctx, authorization, settings)
}

func (s shortMapper) Mutation_refreshSession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (AuthenticatedSession, error) {
	return s.r.Mutation().RefreshSession(ctx, privilegedAuthz, authorization)
}

func (s shortMapper) Mutation_destroySession(ctx context.Context, privilegedAuthz PrivilegedAuthorizationInput, authorization AuthorizationInput) (bool, error) {
	return s.r.Mutation().DestroySession(ctx, privilegedAuthz, authorization)
}

func (s shortMapper) Mutation_destroyAllSessions(ctx context.Context, authorization PrivilegedAuthorizationInput) (AuthenticatedSessionsCount, error) {
	return s.r.Mutation().DestroyAllSessions(ctx, authorization)
}

func (s shortMapper) Mutation_saveURLsinText(ctx context.Context, authorization AuthorizationInput, destination StorageDestinationInput, text string) (*HarvestedResources, error) {
	return s.r.Mutation().SaveURLsinText(ctx, authorization, destination, text)
}

func (s shortMapper) Query_asymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error) {
	return s.r.Query().AsymmetricCryptoPublicKey(ctx, claimType, keyId)
}

func (s shortMapper) Query_asymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error) {
	return s.r.Query().AsymmetricCryptoPublicKeys(ctx, claimType)
}

func (s shortMapper) Query_settingsBundles(ctx context.Context, authorization PrivilegedAuthorizationInput) ([]*SettingsBundle, error) {
	return s.r.Query().SettingsBundles(ctx, authorization)
}

func (s shortMapper) Query_settingsBundle(ctx context.Context, authorization PrivilegedAuthorizationInput, name SettingsBundleName) (*SettingsBundle, error) {
	return s.r.Query().SettingsBundle(ctx, authorization, name)
}

func (s shortMapper) Query_urlsInText(ctx context.Context, authorization AuthorizationInput, text string) (*HarvestedResources, error) {
	return s.r.Query().UrlsInText(ctx, authorization, text)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var fileStorageSettingsImplementors = []string{"FileStorageSettings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FileStorageSettings(ctx context.Context, sel []query.Selection, obj *FileStorageSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, fileStorageSettingsImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileStorageSettings")
		case "basePath":
			out.Values[i] = ec._FileStorageSettings_basePath(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _FileStorageSettings_basePath(ctx context.Context, field graphql.CollectedField, obj *FileStorageSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "FileStorageSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.BasePath
	return graphql.MarshalString(res)
}

var harvestDirectivesSettingsImplementors = []string{"HarvestDirectivesSettings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestDirectivesSettings(ctx context.Context, sel []query.Selection, obj *HarvestDirectivesSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestDirectivesSettingsImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestDirectivesSettings")
		case "ignoreURLsRegExprs":
			out.Values[i] = ec._HarvestDirectivesSettings_ignoreURLsRegExprs(ctx, field, obj)
		case "removeParamsFromURLsRegEx":
			out.Values[i] = ec._HarvestDirectivesSettings_removeParamsFromURLsRegEx(ctx, field, obj)
		case "followHTMLRedirects":
			out.Values[i] = ec._HarvestDirectivesSettings_followHTMLRedirects(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestDirectivesSettings_ignoreURLsRegExprs(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IgnoreURLsRegExprs
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestDirectivesSettings_removeParamsFromURLsRegEx(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.RemoveParamsFromURLsRegEx
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestDirectivesSettings_followHTMLRedirects(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FollowHTMLRedirects
	return graphql.MarshalBoolean(res)
}

var harvestedResourceImplementors = []string{"HarvestedResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResource(ctx context.Context, sel []query.Selection, obj *HarvestedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResource")
		case "urls":
			out.Values[i] = ec._HarvestedResource_urls(ctx, field, obj)
		case "isHTMLRedirect":
			out.Values[i] = ec._HarvestedResource_isHTMLRedirect(ctx, field, obj)
		case "isCleaned":
			out.Values[i] = ec._HarvestedResource_isCleaned(ctx, field, obj)
		case "redirectURL":
			out.Values[i] = ec._HarvestedResource_redirectURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResource_urls(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Urls
	return ec._HarvestedResourceUrls(ctx, field.Selections, &res)
}

func (ec *executionContext) _HarvestedResource_isHTMLRedirect(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsHTMLRedirect
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _HarvestedResource_isCleaned(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsCleaned
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _HarvestedResource_redirectURL(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.RedirectURL
	if res == nil {
		return graphql.Null
	}
	return *res
}

var harvestedResourceUrlsImplementors = []string{"HarvestedResourceUrls"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResourceUrls(ctx context.Context, sel []query.Selection, obj *HarvestedResourceUrls) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourceUrlsImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResourceUrls")
		case "original":
			out.Values[i] = ec._HarvestedResourceUrls_original(ctx, field, obj)
		case "final":
			out.Values[i] = ec._HarvestedResourceUrls_final(ctx, field, obj)
		case "cleaned":
			out.Values[i] = ec._HarvestedResourceUrls_cleaned(ctx, field, obj)
		case "resolved":
			out.Values[i] = ec._HarvestedResourceUrls_resolved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResourceUrls_original(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Original
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_final(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Final
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_cleaned(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cleaned
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_resolved(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Resolved
	return res
}

var harvestedResourcesImplementors = []string{"HarvestedResources"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResources(ctx context.Context, sel []query.Selection, obj *HarvestedResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourcesImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResources")
		case "text":
			out.Values[i] = ec._HarvestedResources_text(ctx, field, obj)
		case "harvested":
			out.Values[i] = ec._HarvestedResources_harvested(ctx, field, obj)
		case "ignored":
			out.Values[i] = ec._HarvestedResources_ignored(ctx, field, obj)
		case "invalid":
			out.Values[i] = ec._HarvestedResources_invalid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResources_text(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Text
	return graphql.MarshalString(res)
}

func (ec *executionContext) _HarvestedResources_harvested(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Harvested
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._HarvestedResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestedResources_ignored(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Ignored
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._IgnoredResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestedResources_invalid(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Invalid
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._UnharvestedResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var ignoredResourceImplementors = []string{"IgnoredResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _IgnoredResource(ctx context.Context, sel []query.Selection, obj *IgnoredResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, ignoredResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IgnoredResource")
		case "urls":
			out.Values[i] = ec._IgnoredResource_urls(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._IgnoredResource_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _IgnoredResource_urls(ctx context.Context, field graphql.CollectedField, obj *IgnoredResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "IgnoredResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Urls
	return ec._HarvestedResourceUrls(ctx, field.Selections, &res)
}

func (ec *executionContext) _IgnoredResource_reason(ctx context.Context, field graphql.CollectedField, obj *IgnoredResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "IgnoredResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Reason
	return graphql.MarshalString(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "establishSimulatedSession":
			out.Values[i] = ec._Mutation_establishSimulatedSession(ctx, field)
		case "refreshSession":
			out.Values[i] = ec._Mutation_refreshSession(ctx, field)
		case "destroySession":
			out.Values[i] = ec._Mutation_destroySession(ctx, field)
		case "destroyAllSessions":
			out.Values[i] = ec._Mutation_destroyAllSessions(ctx, field)
		case "saveURLsinText":
			out.Values[i] = ec._Mutation_saveURLsinText(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_establishSimulatedSession(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	var arg1 SettingsBundleName
	if tmp, ok := field.Args["settings"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "DEFAULT"
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["settings"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_establishSimulatedSession(ctx, args["authorization"].(PrivilegedAuthorizationInput), args["settings"].(SettingsBundleName))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AuthenticatedSession)
	return ec._AuthenticatedSession(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_refreshSession(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["privilegedAuthz"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["privilegedAuthz"] = arg0
	var arg1 AuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg1, err = UnmarshalAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_refreshSession(ctx, args["privilegedAuthz"].(PrivilegedAuthorizationInput), args["authorization"].(AuthorizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AuthenticatedSession)
	return ec._AuthenticatedSession(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_destroySession(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["privilegedAuthz"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["privilegedAuthz"] = arg0
	var arg1 AuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg1, err = UnmarshalAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_destroySession(ctx, args["privilegedAuthz"].(PrivilegedAuthorizationInput), args["authorization"].(AuthorizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _Mutation_destroyAllSessions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_destroyAllSessions(ctx, args["authorization"].(PrivilegedAuthorizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AuthenticatedSessionsCount)
	return res
}

func (ec *executionContext) _Mutation_saveURLsinText(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	var arg1 StorageDestinationInput
	if tmp, ok := field.Args["destination"]; ok {
		var err error
		arg1, err = UnmarshalStorageDestinationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["destination"] = arg1
	var arg2 string
	if tmp, ok := field.Args["text"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["text"] = arg2
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_saveURLsinText(ctx, args["authorization"].(AuthorizationInput), args["destination"].(StorageDestinationInput), args["text"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HarvestedResources)
	if res == nil {
		return graphql.Null
	}
	return ec._HarvestedResources(ctx, field.Selections, res)
}

var organizationImplementors = []string{"Organization", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Organization(ctx context.Context, sel []query.Selection, obj *Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, organizationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
		case "units":
			out.Values[i] = ec._Organization_units(ctx, field, obj)
		case "services":
			out.Values[i] = ec._Organization_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Organization_units(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Units
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._OrganizationalUnit(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Organization_services(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var organizationalUnitImplementors = []string{"OrganizationalUnit", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OrganizationalUnit(ctx context.Context, sel []query.Selection, obj *OrganizationalUnit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, organizationalUnitImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationalUnit")
		case "id":
			out.Values[i] = ec._OrganizationalUnit_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._OrganizationalUnit_name(ctx, field, obj)
		case "units":
			out.Values[i] = ec._OrganizationalUnit_units(ctx, field, obj)
		case "services":
			out.Values[i] = ec._OrganizationalUnit_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OrganizationalUnit_id(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _OrganizationalUnit_name(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _OrganizationalUnit_units(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Units
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._OrganizationalUnit(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _OrganizationalUnit_services(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var personImplementors = []string{"Person", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Person(ctx context.Context, sel []query.Selection, obj *Person) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, personImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Person")
		case "id":
			out.Values[i] = ec._Person_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Person_name(ctx, field, obj)
		case "firstName":
			out.Values[i] = ec._Person_firstName(ctx, field, obj)
		case "lastName":
			out.Values[i] = ec._Person_lastName(ctx, field, obj)
		case "users":
			out.Values[i] = ec._Person_users(ctx, field, obj)
		case "services":
			out.Values[i] = ec._Person_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Person_id(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Person_name(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_firstName(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FirstName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_lastName(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.LastName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_users(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Users
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._UserIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Person_services(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "asymmetricCryptoPublicKey":
			out.Values[i] = ec._Query_asymmetricCryptoPublicKey(ctx, field)
		case "asymmetricCryptoPublicKeys":
			out.Values[i] = ec._Query_asymmetricCryptoPublicKeys(ctx, field)
		case "settingsBundles":
			out.Values[i] = ec._Query_settingsBundles(ctx, field)
		case "settingsBundle":
			out.Values[i] = ec._Query_settingsBundle(ctx, field)
		case "urlsInText":
			out.Values[i] = ec._Query_urlsInText(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_asymmetricCryptoPublicKey(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthorizationClaimType
	if tmp, ok := field.Args["claimType"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["claimType"] = arg0
	var arg1 string
	if tmp, ok := field.Args["keyId"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["keyId"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_asymmetricCryptoPublicKey(ctx, args["claimType"].(AuthorizationClaimType), args["keyId"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(AuthorizationClaimCryptoKey)
		return ec._AuthorizationClaimCryptoKey(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_asymmetricCryptoPublicKeys(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *AuthorizationClaimType
	if tmp, ok := field.Args["claimType"]; ok {
		var err error
		var ptr1 AuthorizationClaimType
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["claimType"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_asymmetricCryptoPublicKeys(ctx, args["claimType"].(*AuthorizationClaimType))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*AuthorizationClaimCryptoKey)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._AuthorizationClaimCryptoKey(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Query_settingsBundles(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_settingsBundles(ctx, args["authorization"].(PrivilegedAuthorizationInput))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*SettingsBundle)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._SettingsBundle(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Query_settingsBundle(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 PrivilegedAuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalPrivilegedAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	var arg1 SettingsBundleName
	if tmp, ok := field.Args["name"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_settingsBundle(ctx, args["authorization"].(PrivilegedAuthorizationInput), args["name"].(SettingsBundleName))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*SettingsBundle)
		if res == nil {
			return graphql.Null
		}
		return ec._SettingsBundle(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query_urlsInText(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthorizationInput
	if tmp, ok := field.Args["authorization"]; ok {
		var err error
		arg0, err = UnmarshalAuthorizationInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["authorization"] = arg0
	var arg1 string
	if tmp, ok := field.Args["text"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["text"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_urlsInText(ctx, args["authorization"].(AuthorizationInput), args["text"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*HarvestedResources)
		if res == nil {
			return graphql.Null
		}
		return ec._HarvestedResources(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var serviceIdentityImplementors = []string{"ServiceIdentity", "AuthenticationIdentity"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceIdentity(ctx context.Context, sel []query.Selection, obj *ServiceIdentity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, serviceIdentityImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceIdentity")
		case "id":
			out.Values[i] = ec._ServiceIdentity_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ServiceIdentity_type(ctx, field, obj)
		case "principal":
			out.Values[i] = ec._ServiceIdentity_principal(ctx, field, obj)
		case "key":
			out.Values[i] = ec._ServiceIdentity_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ServiceIdentity_id(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _ServiceIdentity_type(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _ServiceIdentity_principal(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Principal
	return res
}

func (ec *executionContext) _ServiceIdentity_key(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Key
	return res
}

var settingsBundleImplementors = []string{"SettingsBundle"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SettingsBundle(ctx context.Context, sel []query.Selection, obj *SettingsBundle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, settingsBundleImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SettingsBundle")
		case "name":
			out.Values[i] = ec._SettingsBundle_name(ctx, field, obj)
		case "storage":
			out.Values[i] = ec._SettingsBundle_storage(ctx, field, obj)
		case "harvest":
			out.Values[i] = ec._SettingsBundle_harvest(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._SettingsBundle_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SettingsBundle_name(ctx context.Context, field graphql.CollectedField, obj *SettingsBundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SettingsBundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return res
}

func (ec *executionContext) _SettingsBundle_storage(ctx context.Context, field graphql.CollectedField, obj *SettingsBundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SettingsBundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Storage
	return ec._StorageSettings(ctx, field.Selections, &res)
}

func (ec *executionContext) _SettingsBundle_harvest(ctx context.Context, field graphql.CollectedField, obj *SettingsBundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SettingsBundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Harvest
	return ec._HarvestDirectivesSettings(ctx, field.Selections, &res)
}

func (ec *executionContext) _SettingsBundle_errors(ctx context.Context, field graphql.CollectedField, obj *SettingsBundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SettingsBundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Errors
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

var storageSettingsImplementors = []string{"StorageSettings"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StorageSettings(ctx context.Context, sel []query.Selection, obj *StorageSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, storageSettingsImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageSettings")
		case "type":
			out.Values[i] = ec._StorageSettings_type(ctx, field, obj)
		case "filesys":
			out.Values[i] = ec._StorageSettings_filesys(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _StorageSettings_type(ctx context.Context, field graphql.CollectedField, obj *StorageSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StorageSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _StorageSettings_filesys(ctx context.Context, field graphql.CollectedField, obj *StorageSettings) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StorageSettings"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Filesys
	if res == nil {
		return graphql.Null
	}
	return ec._FileStorageSettings(ctx, field.Selections, res)
}

var tenantImplementors = []string{"Tenant", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Tenant(ctx context.Context, sel []query.Selection, obj *Tenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, tenantImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tenant")
		case "id":
			out.Values[i] = ec._Tenant_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Tenant_name(ctx, field, obj)
		case "org":
			out.Values[i] = ec._Tenant_org(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Tenant_id(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Tenant_name(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Tenant_org(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Org
	return ec._Organization(ctx, field.Selections, &res)
}

var unharvestedResourceImplementors = []string{"UnharvestedResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UnharvestedResource(ctx context.Context, sel []query.Selection, obj *UnharvestedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, unharvestedResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnharvestedResource")
		case "url":
			out.Values[i] = ec._UnharvestedResource_url(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._UnharvestedResource_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UnharvestedResource_url(ctx context.Context, field graphql.CollectedField, obj *UnharvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UnharvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Url
	return res
}

func (ec *executionContext) _UnharvestedResource_reason(ctx context.Context, field graphql.CollectedField, obj *UnharvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UnharvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Reason
	return graphql.MarshalString(res)
}

var userIdentityImplementors = []string{"UserIdentity", "AuthenticationIdentity"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UserIdentity(ctx context.Context, sel []query.Selection, obj *UserIdentity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, userIdentityImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserIdentity")
		case "id":
			out.Values[i] = ec._UserIdentity_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._UserIdentity_type(ctx, field, obj)
		case "principal":
			out.Values[i] = ec._UserIdentity_principal(ctx, field, obj)
		case "password":
			out.Values[i] = ec._UserIdentity_password(ctx, field, obj)
		case "person":
			out.Values[i] = ec._UserIdentity_person(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UserIdentity_id(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _UserIdentity_type(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _UserIdentity_principal(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Principal
	return res
}

func (ec *executionContext) _UserIdentity_password(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Password
	return res
}

func (ec *executionContext) _UserIdentity_person(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Person
	return ec._Person(ctx, field.Selections, &res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthenticatedSession(ctx context.Context, sel []query.Selection, obj *AuthenticatedSession) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthenticationIdentity(ctx context.Context, sel []query.Selection, obj *AuthenticationIdentity) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case UserIdentity:
		return ec._UserIdentity(ctx, sel, &obj)
	case *UserIdentity:
		return ec._UserIdentity(ctx, sel, obj)
	case ServiceIdentity:
		return ec._ServiceIdentity(ctx, sel, &obj)
	case *ServiceIdentity:
		return ec._ServiceIdentity(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthorizationClaimCryptoKey(ctx context.Context, sel []query.Selection, obj *AuthorizationClaimCryptoKey) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Party(ctx context.Context, sel []query.Selection, obj *Party) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case Person:
		return ec._Person(ctx, sel, &obj)
	case *Person:
		return ec._Person(ctx, sel, obj)
	case OrganizationalUnit:
		return ec._OrganizationalUnit(ctx, sel, &obj)
	case *OrganizationalUnit:
		return ec._OrganizationalUnit(ctx, sel, obj)
	case Organization:
		return ec._Organization(ctx, sel, &obj)
	case *Organization:
		return ec._Organization(ctx, sel, obj)
	case Tenant:
		return ec._Tenant(ctx, sel, &obj)
	case *Tenant:
		return ec._Tenant(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalAuthorizationInput(v interface{}) (AuthorizationInput, error) {
	var it AuthorizationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "claimType":
			var err error
			err = (&it.ClaimType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "claimMedium":
			var err error
			err = (&it.ClaimMedium).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "sessionID":
			var err error
			var ptr1 AuthenticatedSessionID
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.SessionID = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalPrivilegedAuthorizationInput(v interface{}) (PrivilegedAuthorizationInput, error) {
	var it PrivilegedAuthorizationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "claimType":
			var err error
			err = (&it.ClaimType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "claimMedium":
			var err error
			err = (&it.ClaimMedium).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "sessionID":
			var err error
			var ptr1 AuthenticatedSessionID
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.SessionID = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalStorageDestinationInput(v interface{}) (StorageDestinationInput, error) {
	var it StorageDestinationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "collection":
			var err error
			err = (&it.Collection).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			err = (&it.Key).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`# TODO Add [feature flags/toggles](https://martinfowler.com/articles/feature-toggles.html) data types and fields.
#      The schema should help manage what fields should be turned on/off per tenant, time, authorization, etc.

scalar SmallText
scalar MediumText
scalar LargeText
scalar ExtraLargeText
scalar AsymmetricCryptoPublicKey
scalar AuthenticatedSessionID
scalar AuthenticatedSessionsCount
scalar URLText
scalar RegularExpression
scalar ErrorMessage

scalar IdentityPrincipal
scalar IdentityPassword
scalar IdentityKey

scalar StorageKey
scalar SettingsBundleName

scalar Document
scalar File

scalar Date
scalar PastDate
scalar FutureDate
scalar DateTime
scalar PastDateTime
scalar FutureDateTime
scalar Timestamp

scalar AuthenticatedSessionTimeout

enum AuthorizationClaimType {
  SESSION_ID
  JWT
}

enum AuthorizationClaimMedium {
  HTTP_HEADER
  PARAM_VALUE  
}

enum AuthenticationType {
  SINGLE_FACTOR
}

enum AuthenticatedSessionType {
  EPHEMERAL
}

enum AuthenticatedSessionTmeoutType {
  SLIDING_WINDOW
  ABSOLUTE
}

interface AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
}

interface AuthorizationClaimCryptoKey {
  claimType : AuthorizationClaimType!
  keyId : String!
  key : AsymmetricCryptoPublicKey!
}

interface AuthenticatedSession {
  claimType : AuthorizationClaimType!
  claimMedium : AuthorizationClaimMedium!
  claimKey : AuthorizationClaimCryptoKey
  sessionID: AuthenticatedSessionID!
  type: AuthenticatedSessionType!
  identity: AuthenticationIdentity!
  timeOutType : AuthenticatedSessionTmeoutType!
  timeOut: AuthenticatedSessionTimeout!
  settingsBundleName : SettingsBundleName
}

interface Party {
  id: ID!
  name: String!  
}

type Person implements Party {
  id: ID!
  name: String!
  firstName: String!
  lastName: String!
  users : [UserIdentity]
  services : [ServiceIdentity]
}

type UserIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  password : IdentityPassword!
  person: Person!
}

type ServiceIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  key : IdentityKey!
}

type OrganizationalUnit implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Organization implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Tenant implements Party {
  id: ID!
  name: String!
  org: Organization!
}

# StorageType enumerates the different kinds of storage Lectio supports
enum StorageType {
  FILE_SYSTEM
}

type FileStorageSettings {
  basePath : String!
}

type StorageSettings {
  type: StorageType!
  filesys : FileStorageSettings
}

type HarvestDirectivesSettings {
  ignoreURLsRegExprs : [RegularExpression]
  removeParamsFromURLsRegEx : [RegularExpression]
  followHTMLRedirects : Boolean!
}

type SettingsBundle {
  name : SettingsBundleName!
  storage: StorageSettings!
  harvest : HarvestDirectivesSettings!
  errors: [ErrorMessage]
}

type HarvestedResourceUrls {
  original : URLText!
  final : URLText!
  cleaned : URLText!
  resolved : URLText!
}

type HarvestedResource {
  urls : HarvestedResourceUrls!
  isHTMLRedirect : Boolean!
  isCleaned : Boolean!
  redirectURL : URLText
}

type IgnoredResource {
  urls : HarvestedResourceUrls!
  reason: String!
}

type UnharvestedResource {
  url : URLText!
  reason: String!
}

type HarvestedResources {
  text: String!
  harvested: [HarvestedResource]
  ignored : [IgnoredResource]
  invalid : [UnharvestedResource]
}

input AuthorizationInput {
  claimType : AuthorizationClaimType!
  claimMedium : AuthorizationClaimMedium!
  sessionID: AuthenticatedSessionID
}

input PrivilegedAuthorizationInput {
  claimType : AuthorizationClaimType!
  claimMedium : AuthorizationClaimMedium!
  sessionID: AuthenticatedSessionID
}

enum StorageDestinationCollection {
  SESSION_PRINCIPAL
  SESSION_TENANT
}

input StorageDestinationInput {
  collection : StorageDestinationCollection!
  key: StorageKey!
}

type Query {
  asymmetricCryptoPublicKey(claimType : AuthorizationClaimType!, keyId : String!) : AuthorizationClaimCryptoKey
  asymmetricCryptoPublicKeys(claimType : AuthorizationClaimType) : [AuthorizationClaimCryptoKey]
  settingsBundles(authorization : PrivilegedAuthorizationInput!) : [SettingsBundle]
  settingsBundle(authorization : PrivilegedAuthorizationInput!, name : SettingsBundleName!): SettingsBundle
  urlsInText(authorization : AuthorizationInput!, text: String!): HarvestedResources
}

type Mutation {
  establishSimulatedSession(authorization : PrivilegedAuthorizationInput!, settings : SettingsBundleName = "DEFAULT") : AuthenticatedSession
  refreshSession(privilegedAuthz : PrivilegedAuthorizationInput!, authorization : AuthorizationInput!) : AuthenticatedSession
  destroySession(privilegedAuthz : PrivilegedAuthorizationInput!, authorization : AuthorizationInput!) : Boolean!
  destroyAllSessions(authorization : PrivilegedAuthorizationInput!) : AuthenticatedSessionsCount!
  saveURLsinText(authorization : AuthorizationInput!, destination: StorageDestinationInput!, text : String!) : HarvestedResources
}
`)
