// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package schema_defn

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"

	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	Mutation_establishSimulatedSession(ctx context.Context, config ConfigurationName) (AuthenticatedSession, error)
	Mutation_destroySession(ctx context.Context, sessionID AuthenticatedSessionID) (bool, error)
	Mutation_destroyAllSessions(ctx context.Context) (AuthenticatedSessionsCount, error)
	Mutation_saveURLsinText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error)

	Query_asymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error)
	Query_asymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error)
	Query_configs(ctx context.Context, sessionID AuthenticatedSessionID) ([]*Configuration, error)
	Query_config(ctx context.Context, sessionID AuthenticatedSessionID, name ConfigurationName) (*Configuration, error)
	Query_urlsInText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error)
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}
type MutationResolver interface {
	EstablishSimulatedSession(ctx context.Context, config ConfigurationName) (AuthenticatedSession, error)
	DestroySession(ctx context.Context, sessionID AuthenticatedSessionID) (bool, error)
	DestroyAllSessions(ctx context.Context) (AuthenticatedSessionsCount, error)
	SaveURLsinText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error)
}
type QueryResolver interface {
	AsymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error)
	AsymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error)
	Configs(ctx context.Context, sessionID AuthenticatedSessionID) ([]*Configuration, error)
	Config(ctx context.Context, sessionID AuthenticatedSessionID, name ConfigurationName) (*Configuration, error)
	UrlsInText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) Mutation_establishSimulatedSession(ctx context.Context, config ConfigurationName) (AuthenticatedSession, error) {
	return s.r.Mutation().EstablishSimulatedSession(ctx, config)
}

func (s shortMapper) Mutation_destroySession(ctx context.Context, sessionID AuthenticatedSessionID) (bool, error) {
	return s.r.Mutation().DestroySession(ctx, sessionID)
}

func (s shortMapper) Mutation_destroyAllSessions(ctx context.Context) (AuthenticatedSessionsCount, error) {
	return s.r.Mutation().DestroyAllSessions(ctx)
}

func (s shortMapper) Mutation_saveURLsinText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error) {
	return s.r.Mutation().SaveURLsinText(ctx, sessionID, text)
}

func (s shortMapper) Query_asymmetricCryptoPublicKey(ctx context.Context, claimType AuthorizationClaimType, keyId string) (AuthorizationClaimCryptoKey, error) {
	return s.r.Query().AsymmetricCryptoPublicKey(ctx, claimType, keyId)
}

func (s shortMapper) Query_asymmetricCryptoPublicKeys(ctx context.Context, claimType *AuthorizationClaimType) ([]*AuthorizationClaimCryptoKey, error) {
	return s.r.Query().AsymmetricCryptoPublicKeys(ctx, claimType)
}

func (s shortMapper) Query_configs(ctx context.Context, sessionID AuthenticatedSessionID) ([]*Configuration, error) {
	return s.r.Query().Configs(ctx, sessionID)
}

func (s shortMapper) Query_config(ctx context.Context, sessionID AuthenticatedSessionID, name ConfigurationName) (*Configuration, error) {
	return s.r.Query().Config(ctx, sessionID, name)
}

func (s shortMapper) Query_urlsInText(ctx context.Context, sessionID AuthenticatedSessionID, text string) (*HarvestedResources, error) {
	return s.r.Query().UrlsInText(ctx, sessionID, text)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var configurationImplementors = []string{"Configuration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Configuration(ctx context.Context, sel []query.Selection, obj *Configuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, configurationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Configuration")
		case "name":
			out.Values[i] = ec._Configuration_name(ctx, field, obj)
		case "storage":
			out.Values[i] = ec._Configuration_storage(ctx, field, obj)
		case "harvest":
			out.Values[i] = ec._Configuration_harvest(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._Configuration_errors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Configuration_name(ctx context.Context, field graphql.CollectedField, obj *Configuration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Configuration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return res
}

func (ec *executionContext) _Configuration_storage(ctx context.Context, field graphql.CollectedField, obj *Configuration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Configuration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Storage
	return ec._StorageConfiguration(ctx, field.Selections, &res)
}

func (ec *executionContext) _Configuration_harvest(ctx context.Context, field graphql.CollectedField, obj *Configuration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Configuration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Harvest
	return ec._HarvestDirectivesConfiguration(ctx, field.Selections, &res)
}

func (ec *executionContext) _Configuration_errors(ctx context.Context, field graphql.CollectedField, obj *Configuration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Configuration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Errors
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

var fileStorageConfigurationImplementors = []string{"FileStorageConfiguration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FileStorageConfiguration(ctx context.Context, sel []query.Selection, obj *FileStorageConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, fileStorageConfigurationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileStorageConfiguration")
		case "basePath":
			out.Values[i] = ec._FileStorageConfiguration_basePath(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _FileStorageConfiguration_basePath(ctx context.Context, field graphql.CollectedField, obj *FileStorageConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "FileStorageConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.BasePath
	return graphql.MarshalString(res)
}

var harvestDirectivesConfigurationImplementors = []string{"HarvestDirectivesConfiguration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestDirectivesConfiguration(ctx context.Context, sel []query.Selection, obj *HarvestDirectivesConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestDirectivesConfigurationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestDirectivesConfiguration")
		case "ignoreURLsRegExprs":
			out.Values[i] = ec._HarvestDirectivesConfiguration_ignoreURLsRegExprs(ctx, field, obj)
		case "removeParamsFromURLsRegEx":
			out.Values[i] = ec._HarvestDirectivesConfiguration_removeParamsFromURLsRegEx(ctx, field, obj)
		case "followHTMLRedirects":
			out.Values[i] = ec._HarvestDirectivesConfiguration_followHTMLRedirects(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestDirectivesConfiguration_ignoreURLsRegExprs(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IgnoreURLsRegExprs
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestDirectivesConfiguration_removeParamsFromURLsRegEx(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.RemoveParamsFromURLsRegEx
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return *res[idx1]
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestDirectivesConfiguration_followHTMLRedirects(ctx context.Context, field graphql.CollectedField, obj *HarvestDirectivesConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestDirectivesConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FollowHTMLRedirects
	return graphql.MarshalBoolean(res)
}

var harvestedResourceImplementors = []string{"HarvestedResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResource(ctx context.Context, sel []query.Selection, obj *HarvestedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResource")
		case "urls":
			out.Values[i] = ec._HarvestedResource_urls(ctx, field, obj)
		case "isHTMLRedirect":
			out.Values[i] = ec._HarvestedResource_isHTMLRedirect(ctx, field, obj)
		case "isCleaned":
			out.Values[i] = ec._HarvestedResource_isCleaned(ctx, field, obj)
		case "redirectURL":
			out.Values[i] = ec._HarvestedResource_redirectURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResource_urls(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Urls
	return ec._HarvestedResourceUrls(ctx, field.Selections, &res)
}

func (ec *executionContext) _HarvestedResource_isHTMLRedirect(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsHTMLRedirect
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _HarvestedResource_isCleaned(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsCleaned
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _HarvestedResource_redirectURL(ctx context.Context, field graphql.CollectedField, obj *HarvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.RedirectURL
	if res == nil {
		return graphql.Null
	}
	return *res
}

var harvestedResourceUrlsImplementors = []string{"HarvestedResourceUrls"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResourceUrls(ctx context.Context, sel []query.Selection, obj *HarvestedResourceUrls) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourceUrlsImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResourceUrls")
		case "original":
			out.Values[i] = ec._HarvestedResourceUrls_original(ctx, field, obj)
		case "final":
			out.Values[i] = ec._HarvestedResourceUrls_final(ctx, field, obj)
		case "cleaned":
			out.Values[i] = ec._HarvestedResourceUrls_cleaned(ctx, field, obj)
		case "resolved":
			out.Values[i] = ec._HarvestedResourceUrls_resolved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResourceUrls_original(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Original
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_final(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Final
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_cleaned(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Cleaned
	return res
}

func (ec *executionContext) _HarvestedResourceUrls_resolved(ctx context.Context, field graphql.CollectedField, obj *HarvestedResourceUrls) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResourceUrls"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Resolved
	return res
}

var harvestedResourcesImplementors = []string{"HarvestedResources"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _HarvestedResources(ctx context.Context, sel []query.Selection, obj *HarvestedResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, harvestedResourcesImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HarvestedResources")
		case "text":
			out.Values[i] = ec._HarvestedResources_text(ctx, field, obj)
		case "harvested":
			out.Values[i] = ec._HarvestedResources_harvested(ctx, field, obj)
		case "ignored":
			out.Values[i] = ec._HarvestedResources_ignored(ctx, field, obj)
		case "invalid":
			out.Values[i] = ec._HarvestedResources_invalid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _HarvestedResources_text(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Text
	return graphql.MarshalString(res)
}

func (ec *executionContext) _HarvestedResources_harvested(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Harvested
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._HarvestedResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestedResources_ignored(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Ignored
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._IgnoredResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _HarvestedResources_invalid(ctx context.Context, field graphql.CollectedField, obj *HarvestedResources) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "HarvestedResources"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Invalid
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._UnharvestedResource(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var ignoredResourceImplementors = []string{"IgnoredResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _IgnoredResource(ctx context.Context, sel []query.Selection, obj *IgnoredResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, ignoredResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IgnoredResource")
		case "urls":
			out.Values[i] = ec._IgnoredResource_urls(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._IgnoredResource_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _IgnoredResource_urls(ctx context.Context, field graphql.CollectedField, obj *IgnoredResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "IgnoredResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Urls
	return ec._HarvestedResourceUrls(ctx, field.Selections, &res)
}

func (ec *executionContext) _IgnoredResource_reason(ctx context.Context, field graphql.CollectedField, obj *IgnoredResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "IgnoredResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Reason
	return graphql.MarshalString(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "establishSimulatedSession":
			out.Values[i] = ec._Mutation_establishSimulatedSession(ctx, field)
		case "destroySession":
			out.Values[i] = ec._Mutation_destroySession(ctx, field)
		case "destroyAllSessions":
			out.Values[i] = ec._Mutation_destroyAllSessions(ctx, field)
		case "saveURLsinText":
			out.Values[i] = ec._Mutation_saveURLsinText(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_establishSimulatedSession(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 ConfigurationName
	if tmp, ok := field.Args["config"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "DEFAULT"
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["config"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_establishSimulatedSession(ctx, args["config"].(ConfigurationName))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AuthenticatedSession)
	return ec._AuthenticatedSession(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_destroySession(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthenticatedSessionID
	if tmp, ok := field.Args["sessionID"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["sessionID"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_destroySession(ctx, args["sessionID"].(AuthenticatedSessionID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) _Mutation_destroyAllSessions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_destroyAllSessions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(AuthenticatedSessionsCount)
	return res
}

func (ec *executionContext) _Mutation_saveURLsinText(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthenticatedSessionID
	if tmp, ok := field.Args["sessionID"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "JWT_IN_HTTP_HEADER"
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["sessionID"] = arg0
	var arg1 string
	if tmp, ok := field.Args["text"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["text"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_saveURLsinText(ctx, args["sessionID"].(AuthenticatedSessionID), args["text"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HarvestedResources)
	if res == nil {
		return graphql.Null
	}
	return ec._HarvestedResources(ctx, field.Selections, res)
}

var organizationImplementors = []string{"Organization", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Organization(ctx context.Context, sel []query.Selection, obj *Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, organizationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
		case "units":
			out.Values[i] = ec._Organization_units(ctx, field, obj)
		case "services":
			out.Values[i] = ec._Organization_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Organization_units(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Units
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._OrganizationalUnit(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Organization_services(ctx context.Context, field graphql.CollectedField, obj *Organization) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Organization"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var organizationalUnitImplementors = []string{"OrganizationalUnit", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OrganizationalUnit(ctx context.Context, sel []query.Selection, obj *OrganizationalUnit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, organizationalUnitImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationalUnit")
		case "id":
			out.Values[i] = ec._OrganizationalUnit_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._OrganizationalUnit_name(ctx, field, obj)
		case "units":
			out.Values[i] = ec._OrganizationalUnit_units(ctx, field, obj)
		case "services":
			out.Values[i] = ec._OrganizationalUnit_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OrganizationalUnit_id(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _OrganizationalUnit_name(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _OrganizationalUnit_units(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Units
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._OrganizationalUnit(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _OrganizationalUnit_services(ctx context.Context, field graphql.CollectedField, obj *OrganizationalUnit) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OrganizationalUnit"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var personImplementors = []string{"Person", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Person(ctx context.Context, sel []query.Selection, obj *Person) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, personImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Person")
		case "id":
			out.Values[i] = ec._Person_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Person_name(ctx, field, obj)
		case "firstName":
			out.Values[i] = ec._Person_firstName(ctx, field, obj)
		case "lastName":
			out.Values[i] = ec._Person_lastName(ctx, field, obj)
		case "users":
			out.Values[i] = ec._Person_users(ctx, field, obj)
		case "services":
			out.Values[i] = ec._Person_services(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Person_id(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Person_name(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_firstName(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FirstName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_lastName(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.LastName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Person_users(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Users
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._UserIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Person_services(ctx context.Context, field graphql.CollectedField, obj *Person) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Person"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Services
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ServiceIdentity(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "asymmetricCryptoPublicKey":
			out.Values[i] = ec._Query_asymmetricCryptoPublicKey(ctx, field)
		case "asymmetricCryptoPublicKeys":
			out.Values[i] = ec._Query_asymmetricCryptoPublicKeys(ctx, field)
		case "configs":
			out.Values[i] = ec._Query_configs(ctx, field)
		case "config":
			out.Values[i] = ec._Query_config(ctx, field)
		case "urlsInText":
			out.Values[i] = ec._Query_urlsInText(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_asymmetricCryptoPublicKey(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthorizationClaimType
	if tmp, ok := field.Args["claimType"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["claimType"] = arg0
	var arg1 string
	if tmp, ok := field.Args["keyId"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["keyId"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_asymmetricCryptoPublicKey(ctx, args["claimType"].(AuthorizationClaimType), args["keyId"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(AuthorizationClaimCryptoKey)
		return ec._AuthorizationClaimCryptoKey(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_asymmetricCryptoPublicKeys(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *AuthorizationClaimType
	if tmp, ok := field.Args["claimType"]; ok {
		var err error
		var ptr1 AuthorizationClaimType
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["claimType"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_asymmetricCryptoPublicKeys(ctx, args["claimType"].(*AuthorizationClaimType))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*AuthorizationClaimCryptoKey)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._AuthorizationClaimCryptoKey(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Query_configs(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthenticatedSessionID
	if tmp, ok := field.Args["sessionID"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "JWT_IN_HTTP_HEADER"
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["sessionID"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_configs(ctx, args["sessionID"].(AuthenticatedSessionID))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*Configuration)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._Configuration(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Query_config(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthenticatedSessionID
	if tmp, ok := field.Args["sessionID"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "JWT_IN_HTTP_HEADER"
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["sessionID"] = arg0
	var arg1 ConfigurationName
	if tmp, ok := field.Args["name"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_config(ctx, args["sessionID"].(AuthenticatedSessionID), args["name"].(ConfigurationName))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*Configuration)
		if res == nil {
			return graphql.Null
		}
		return ec._Configuration(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query_urlsInText(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 AuthenticatedSessionID
	if tmp, ok := field.Args["sessionID"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = "JWT_IN_HTTP_HEADER"
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}

	args["sessionID"] = arg0
	var arg1 string
	if tmp, ok := field.Args["text"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["text"] = arg1
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_urlsInText(ctx, args["sessionID"].(AuthenticatedSessionID), args["text"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*HarvestedResources)
		if res == nil {
			return graphql.Null
		}
		return ec._HarvestedResources(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var serviceIdentityImplementors = []string{"ServiceIdentity", "AuthenticationIdentity"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ServiceIdentity(ctx context.Context, sel []query.Selection, obj *ServiceIdentity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, serviceIdentityImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceIdentity")
		case "id":
			out.Values[i] = ec._ServiceIdentity_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ServiceIdentity_type(ctx, field, obj)
		case "principal":
			out.Values[i] = ec._ServiceIdentity_principal(ctx, field, obj)
		case "key":
			out.Values[i] = ec._ServiceIdentity_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ServiceIdentity_id(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _ServiceIdentity_type(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _ServiceIdentity_principal(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Principal
	return res
}

func (ec *executionContext) _ServiceIdentity_key(ctx context.Context, field graphql.CollectedField, obj *ServiceIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ServiceIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Key
	return res
}

var storageConfigurationImplementors = []string{"StorageConfiguration"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StorageConfiguration(ctx context.Context, sel []query.Selection, obj *StorageConfiguration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, storageConfigurationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StorageConfiguration")
		case "type":
			out.Values[i] = ec._StorageConfiguration_type(ctx, field, obj)
		case "filesys":
			out.Values[i] = ec._StorageConfiguration_filesys(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _StorageConfiguration_type(ctx context.Context, field graphql.CollectedField, obj *StorageConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StorageConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _StorageConfiguration_filesys(ctx context.Context, field graphql.CollectedField, obj *StorageConfiguration) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StorageConfiguration"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Filesys
	if res == nil {
		return graphql.Null
	}
	return ec._FileStorageConfiguration(ctx, field.Selections, res)
}

var tenantImplementors = []string{"Tenant", "Party"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Tenant(ctx context.Context, sel []query.Selection, obj *Tenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, tenantImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tenant")
		case "id":
			out.Values[i] = ec._Tenant_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Tenant_name(ctx, field, obj)
		case "org":
			out.Values[i] = ec._Tenant_org(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Tenant_id(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Tenant_name(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Tenant_org(ctx context.Context, field graphql.CollectedField, obj *Tenant) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Tenant"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Org
	return ec._Organization(ctx, field.Selections, &res)
}

var unharvestedResourceImplementors = []string{"UnharvestedResource"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UnharvestedResource(ctx context.Context, sel []query.Selection, obj *UnharvestedResource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, unharvestedResourceImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnharvestedResource")
		case "url":
			out.Values[i] = ec._UnharvestedResource_url(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._UnharvestedResource_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UnharvestedResource_url(ctx context.Context, field graphql.CollectedField, obj *UnharvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UnharvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Url
	return res
}

func (ec *executionContext) _UnharvestedResource_reason(ctx context.Context, field graphql.CollectedField, obj *UnharvestedResource) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UnharvestedResource"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Reason
	return graphql.MarshalString(res)
}

var userIdentityImplementors = []string{"UserIdentity", "AuthenticationIdentity"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UserIdentity(ctx context.Context, sel []query.Selection, obj *UserIdentity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, userIdentityImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserIdentity")
		case "id":
			out.Values[i] = ec._UserIdentity_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._UserIdentity_type(ctx, field, obj)
		case "principal":
			out.Values[i] = ec._UserIdentity_principal(ctx, field, obj)
		case "password":
			out.Values[i] = ec._UserIdentity_password(ctx, field, obj)
		case "person":
			out.Values[i] = ec._UserIdentity_person(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UserIdentity_id(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _UserIdentity_type(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

func (ec *executionContext) _UserIdentity_principal(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Principal
	return res
}

func (ec *executionContext) _UserIdentity_password(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Password
	return res
}

func (ec *executionContext) _UserIdentity_person(ctx context.Context, field graphql.CollectedField, obj *UserIdentity) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UserIdentity"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Person
	return ec._Person(ctx, field.Selections, &res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthenticatedSession(ctx context.Context, sel []query.Selection, obj *AuthenticatedSession) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthenticationIdentity(ctx context.Context, sel []query.Selection, obj *AuthenticationIdentity) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case UserIdentity:
		return ec._UserIdentity(ctx, sel, &obj)
	case *UserIdentity:
		return ec._UserIdentity(ctx, sel, obj)
	case ServiceIdentity:
		return ec._ServiceIdentity(ctx, sel, &obj)
	case *ServiceIdentity:
		return ec._ServiceIdentity(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthorizationClaimCryptoKey(ctx context.Context, sel []query.Selection, obj *AuthorizationClaimCryptoKey) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Party(ctx context.Context, sel []query.Selection, obj *Party) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case Person:
		return ec._Person(ctx, sel, &obj)
	case *Person:
		return ec._Person(ctx, sel, obj)
	case OrganizationalUnit:
		return ec._OrganizationalUnit(ctx, sel, &obj)
	case *OrganizationalUnit:
		return ec._OrganizationalUnit(ctx, sel, obj)
	case Organization:
		return ec._Organization(ctx, sel, &obj)
	case *Organization:
		return ec._Organization(ctx, sel, obj)
	case Tenant:
		return ec._Tenant(ctx, sel, &obj)
	case *Tenant:
		return ec._Tenant(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`# scalar SmallText
# scalar MediumText
# scalar LargeText
# scalar ExtraLargeText
scalar AsymmetricCryptoPublicKey
scalar AuthenticatedSessionID
scalar AuthenticatedSessionsCount
scalar URLText
scalar RegularExpression
scalar ErrorMessage
scalar ConfigurationName

scalar IdentityPrincipal
scalar IdentityPassword
scalar IdentityKey

# scalar Document
# scalar File

# scalar Date
# scalar PastDate
# scalar FutureDate
# scalar DateTime
# scalar PastDateTime
# scalar FutureDateTime
# scalar Timestamp

scalar AuthenticatedSessionTimeout

enum AuthorizationClaimType {
  SESSION_ID
  JWT
}

enum AuthorizationClaimMedium {
  HTTP_HEADER
  PARAM_VALUE  
}

enum AuthenticationType {
  SINGLE_FACTOR
}

enum AuthenticatedSessionType {
  EPHEMERAL
}

enum AuthenticatedSessionTmeoutType {
  SLIDING_WINDOW
  ABSOLUTE
}

interface AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
}

interface AuthorizationClaimCryptoKey {
  claimType : AuthorizationClaimType!
  keyId : String!
  key : AsymmetricCryptoPublicKey!
}

interface AuthenticatedSession {
  claimType : AuthorizationClaimType!
  claimMedium : AuthorizationClaimMedium!
  claimKey : AuthorizationClaimCryptoKey
  sessionID: AuthenticatedSessionID!
  type: AuthenticatedSessionType!
  identity: AuthenticationIdentity!
  timeOutType : AuthenticatedSessionTmeoutType!
  timeOut: AuthenticatedSessionTimeout!
  configName : ConfigurationName
}

interface Party {
  id: ID!
  name: String!  
}

type Person implements Party {
  id: ID!
  name: String!
  firstName: String!
  lastName: String!
  users : [UserIdentity]
  services : [ServiceIdentity]
}

type UserIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  password : IdentityPassword!
  person: Person!
}

type ServiceIdentity implements AuthenticationIdentity {
  id: ID!
  type: AuthenticationType!
  principal: IdentityPrincipal!
  key : IdentityKey!
}

type OrganizationalUnit implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Organization implements Party {
  id: ID!
  name: String!
  units: [OrganizationalUnit]
  services : [ServiceIdentity]
}

type Tenant implements Party {
  id: ID!
  name: String!
  org: Organization!
}

# StorageType enumerates the different kinds of storage Lectio supports
enum StorageType {
  FILE_SYSTEM
}

type FileStorageConfiguration {
  basePath : String!
}

type StorageConfiguration {
  type: StorageType!
  filesys : FileStorageConfiguration
}

type HarvestDirectivesConfiguration {
  ignoreURLsRegExprs : [RegularExpression]
  removeParamsFromURLsRegEx : [RegularExpression]
  followHTMLRedirects : Boolean!
}

type Configuration {
  name : ConfigurationName!
  storage: StorageConfiguration!
  harvest : HarvestDirectivesConfiguration!
  errors: [ErrorMessage]
}

type HarvestedResourceUrls {
  original : URLText!
  final : URLText!
  cleaned : URLText!
  resolved : URLText!
}

type HarvestedResource {
  urls : HarvestedResourceUrls!
  isHTMLRedirect : Boolean!
  isCleaned : Boolean!
  redirectURL : URLText
}

type IgnoredResource {
  urls : HarvestedResourceUrls!
  reason: String!
}

type UnharvestedResource {
  url : URLText!
  reason: String!
}

type HarvestedResources {
  text: String!
  harvested: [HarvestedResource]
  ignored : [IgnoredResource]
  invalid : [UnharvestedResource]
}

type Query {
  asymmetricCryptoPublicKey(claimType : AuthorizationClaimType!, keyId : String!) : AuthorizationClaimCryptoKey
  asymmetricCryptoPublicKeys(claimType : AuthorizationClaimType) : [AuthorizationClaimCryptoKey]
  configs(sessionID : AuthenticatedSessionID! = "JWT_IN_HTTP_HEADER") : [Configuration]
  config(sessionID : AuthenticatedSessionID! = "JWT_IN_HTTP_HEADER", name : ConfigurationName!): Configuration
  urlsInText(sessionID : AuthenticatedSessionID! = "JWT_IN_HTTP_HEADER", text: String!): HarvestedResources
}

type Mutation {
  establishSimulatedSession(config : ConfigurationName = "DEFAULT") : AuthenticatedSession
  destroySession(sessionID : AuthenticatedSessionID!) : Boolean!
  destroyAllSessions() : AuthenticatedSessionsCount!
  saveURLsinText(sessionID : AuthenticatedSessionID! = "JWT_IN_HTTP_HEADER", text : String!) : HarvestedResources
}
`)
